<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mitosis Sandbox</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      padding: 1rem;
      background: transparent;
    }

    .mitosis-component {
      width: 100%;
    }

    .mitosis-text {
      margin: 0.5rem 0;
    }

    .mitosis-heading {
      margin: 1rem 0 0.5rem 0;
      font-weight: 600;
    }

    .mitosis-card {
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: 0.5rem;
      margin: 0.5rem 0;
      background: white;
    }

    .mitosis-button {
      padding: 0.5rem 1rem;
      background: var(--color-primary-500, #4a5568);
      color: white;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
      font-size: 1rem;
    }

    .mitosis-button:hover {
      background: var(--color-primary-600, #2d3748);
    }

    .mitosis-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .mitosis-list-empty {
      padding: 1rem;
      color: #666;
      text-align: center;
      font-style: italic;
    }

    .mitosis-error {
      padding: 1rem;
      background: #fee;
      border: 1px solid #fcc;
      border-radius: 0.5rem;
      color: #c33;
    }
  </style>
</head>
<body>
  <div id="mitosis-root"></div>

  <script type="module">
    // Mitosis Sandbox Renderer
    // Runs in isolated iframe context for security

    const root = document.getElementById('mitosis-root');
    let currentState = {};

    // Security: Block dangerous property access
    const dangerousProps = ['__proto__', 'constructor', 'prototype', 'eval', 'Function', 'window', 'document'];

    function resolvePath(path, state) {
      const parts = path.split('.');
      let current = state;
      console.log('[Sandbox] resolvePath:', path, 'parts:', parts, 'initial state:', state);

      for (const part of parts) {
        // Security checks
        if (dangerousProps.includes(part)) {
          console.warn('[Sandbox] Blocked dangerous property:', part);
          return undefined;
        }

        if (!/^[a-zA-Z0-9_\[\]]+$/.test(part)) {
          console.warn('[Sandbox] Invalid property name:', part);
          return undefined;
        }

        if (current === null || current === undefined) {
          console.warn('[Sandbox] Current is null/undefined at part:', part);
          return undefined;
        }

        if (typeof current[part] === 'function') {
          console.warn('[Sandbox] Blocked function access:', part);
          return undefined;
        }

        console.log('[Sandbox] Resolving part:', part, 'current:', current, 'current[part]:', current[part]);
        current = current[part];
      }

      console.log('[Sandbox] resolvePath result:', current);
      return current;
    }

    function resolveBinding(binding, state) {
      if (typeof binding === 'string') {
        // Handle template strings like "{{state.todos}}"
        if (binding.startsWith('{{') && binding.endsWith('}}')) {
          const path = binding.slice(2, -2).trim();
          console.log('[Sandbox] Resolving binding:', binding, 'path:', path, 'state:', state);
          
          // Handle ternary expressions
          if (path.includes('?')) {
            const parts = path.split('?');
            if (parts.length !== 2) return undefined;
            
            const condition = parts[0].trim();
            const rest = parts[1];
            const colonIndex = rest.lastIndexOf(':');
            if (colonIndex === -1) return undefined;
            
            const trueVal = rest.substring(0, colonIndex).trim();
            const falseVal = rest.substring(colonIndex + 1).trim();
            
            const trueIsString = (trueVal.startsWith("'") && trueVal.endsWith("'")) || 
                                 (trueVal.startsWith('"') && falseVal.endsWith('"'));
            const falseIsString = (falseVal.startsWith("'") && falseVal.endsWith("'")) || 
                                  (falseVal.startsWith('"') && falseVal.endsWith('"'));
            
            if (!trueIsString || !falseIsString) return undefined;
            
            const conditionResult = resolvePath(condition, state);
            const trueValue = trueVal.replace(/^['"]|['"]$/g, '');
            const falseValue = falseVal.replace(/^['"]|['"]$/g, '');
            return conditionResult ? trueValue : falseValue;
          }
          
          return resolvePath(path, state);
        }
        
        // Handle static string literals
        if ((binding.startsWith("'") && binding.endsWith("'")) || 
            (binding.startsWith('"') && binding.endsWith('"'))) {
          return binding.slice(1, -1);
        }
        
        return binding;
      }

      if (typeof binding === 'object' && binding !== null) {
        if (binding.code) {
          const code = binding.code.trim();
          if ((code.startsWith("'") && code.endsWith("'")) || 
              (code.startsWith('"') && code.endsWith('"'))) {
            return code.slice(1, -1);
          }
          return resolvePath(code, state);
        }

        if (binding.type === 'mcp_tool_call') {
          return {
            type: 'mcp_tool_call',
            tool: binding.tool,
            params: binding.params || {}
          };
        }
      }

      return binding;
    }

    function renderNode(node, state, parentElement) {
      if (!node || !node.name) return;

      if (node.name === 'text') {
        const textBinding = node.bindings?.text;
        const text = textBinding ? resolveBinding(textBinding, state) : '';
        parentElement.appendChild(document.createTextNode(text));
        return;
      }

      if (node.name === 'div' || node.name === 'span' || node.name === 'section' || 
          node.name === 'article' || node.name === 'header' || node.name === 'footer') {
        const el = document.createElement(node.name);
        const attrs = node.attributes || {};
        const className = attrs.class || attrs.className || '';
        if (className) el.className = className;
        
        // Set other attributes (safely)
        for (const [key, value] of Object.entries(attrs)) {
          if (key !== 'class' && key !== 'className') {
            el.setAttribute(key, String(value));
          }
        }

        if (node.children) {
          node.children.forEach(child => renderNode(child, state, el));
        }

        parentElement.appendChild(el);
        return;
      }

      if (node.name === 'Text') {
        const el = document.createElement('p');
        el.className = 'mitosis-text';
        const textBinding = node.bindings?.text;
        const text = textBinding ? resolveBinding(textBinding, state) : '';
        el.textContent = text;
        parentElement.appendChild(el);
        return;
      }

      if (node.name === 'Heading') {
        const level = node.attributes?.level || 2;
        const el = document.createElement(`h${Math.min(Math.max(level, 1), 6)}`);
        el.className = 'mitosis-heading';
        const textBinding = node.bindings?.text;
        const text = textBinding ? resolveBinding(textBinding, state) : '';
        el.textContent = text;
        parentElement.appendChild(el);
        return;
      }

      if (node.name === 'Card') {
        const el = document.createElement('div');
        el.className = 'mitosis-card';
        if (node.children) {
          node.children.forEach(child => renderNode(child, state, el));
        }
        parentElement.appendChild(el);
        return;
      }

      if (node.name === 'Button') {
        const el = document.createElement('button');
        el.className = 'mitosis-button';
        const textBinding = node.bindings?.text;
        const text = textBinding ? resolveBinding(textBinding, state) : '';
        el.textContent = text;
        
        const onClickBinding = node.bindings?.onClick;
        const onClick = onClickBinding ? resolveBinding(onClickBinding, state) : null;
        
        if (onClick?.type === 'mcp_tool_call') {
          el.onclick = () => {
            // Send MCP tool call to parent
            // Parent will validate origin
            window.parent.postMessage({
              type: 'mcp-tool-call',
              payload: {
                tool: onClick.tool,
                params: onClick.params
              }
            }, '*');
          };
        }

        parentElement.appendChild(el);
        return;
      }

      if (node.name === 'List') {
        const el = document.createElement('div');
        el.className = 'mitosis-list';
        const itemsBinding = node.bindings?.items;
        console.log('[Sandbox] List node:', { itemsBinding, state });
        const items = itemsBinding ? resolveBinding(itemsBinding, state) : [];
        console.log('[Sandbox] Resolved items:', items, 'isArray:', Array.isArray(items), 'length:', items?.length);
        
        if (Array.isArray(items) && items.length > 0) {
          console.log('[Sandbox] Rendering', items.length, 'items');
          items.forEach((item, index) => {
            if (node.children) {
              const itemState = { ...state, item, index };
              node.children.forEach(child => renderNode(child, itemState, el));
            }
          });
        } else {
          console.log('[Sandbox] No items, showing empty state');
          const emptyEl = document.createElement('div');
          emptyEl.className = 'mitosis-list-empty';
          emptyEl.textContent = 'No items';
          el.appendChild(emptyEl);
        }

        parentElement.appendChild(el);
        return;
      }

      if (node.name === 'Show') {
        // Mitosis conditional rendering
        const whenBinding = node.bindings?.when;
        const when = whenBinding ? resolveBinding(whenBinding, state) : false;
        
        if (when) {
          // Render children
          if (node.children) {
            node.children.forEach(child => renderNode(child, state, parentElement));
          }
        } else if (node.bindings?.else) {
          // Render else content
          const elseNode = node.bindings.else;
          if (typeof elseNode === 'object' && elseNode.name) {
            renderNode(elseNode, state, parentElement);
          }
        }
        return;
      }

      if (node.name === 'For') {
        // Mitosis list rendering
        const eachBinding = node.bindings?.each;
        const items = eachBinding ? resolveBinding(eachBinding, state) : [];
        
        if (Array.isArray(items) && items.length > 0 && node.children) {
          items.forEach((item, index) => {
            const itemState = { ...state, item, index };
            node.children.forEach(child => renderNode(child, itemState, parentElement));
          });
        }
        return;
      }

      if (node.name === 'Fragment') {
        // Mitosis fragment - render children directly
        if (node.children) {
          node.children.forEach(child => renderNode(child, state, parentElement));
        }
        return;
      }

      if (node.name === 'Container' || node.name === 'Stack' || node.name === 'Box') {
        const el = document.createElement('div');
        el.className = `mitosis-${node.name.toLowerCase()}`;
        if (node.children) {
          node.children.forEach(child => renderNode(child, state, el));
        }
        parentElement.appendChild(el);
        return;
      }

      // Fallback: render as div
      const el = document.createElement('div');
      el.className = 'mitosis-unknown-component';
      el.setAttribute('data-component', node.name);
      if (node.children) {
        node.children.forEach(child => renderNode(child, state, el));
      }
      parentElement.appendChild(el);
    }

    function render(config) {
      try {
        console.log('[Sandbox] Rendering config:', config);
        root.innerHTML = ''; // Clear previous content
        
        if (!config || !config.nodes) {
          throw new Error('Invalid config: missing nodes');
        }

        const state = config.state || {};
        console.log('[Sandbox] State:', state);
        console.log('[Sandbox] State.todos:', state.todos);
        currentState = state;

        // Wrap state in an object so bindings like {{state.todos}} resolve correctly
        const context = { state };

        config.nodes.forEach(node => {
          renderNode(node, context, root);
        });
        
        console.log('[Sandbox] Render complete. Root children:', root.children.length);
      } catch (err) {
        console.error('[Sandbox] Render error:', err);
        root.innerHTML = `<div class="mitosis-error">Error: ${err.message}</div>`;
        // Parent will validate origin
        window.parent.postMessage({
          type: 'error',
          payload: { message: err.message }
        }, '*');
      }
    }

    // Listen for messages from parent
    window.addEventListener('message', (event) => {
      // Security: Only accept messages from parent window
      if (event.source !== window.parent) {
        console.warn('[Sandbox] Blocked message from non-parent source');
        return;
      }

      const { type, config } = event.data || {};

      if (type === 'render') {
        render(config);
      }
    });

    // Notify parent that sandbox is ready
    // Use '*' origin - parent will validate our messages
    window.parent.postMessage({ type: 'sandbox-ready' }, '*');
  </script>
</body>
</html>

